<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VSPOä¸­æ–‡ç²¾è¯æ”¶é›†å™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ç°¡å–®çš„è‡ªå®šç¾©æ¨£å¼ï¼Œç¢ºä¿èƒŒæ™¯è‰²åœ¨æ‰€æœ‰æƒ…æ³ä¸‹éƒ½æ­£ç¢º */
        body {
            background-color: #111827; /* gray-900 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">

    <div id="app"></div>

    <script type="module">
        // --- å…¨åŸŸè®Šæ•¸èˆ‡ç‹€æ…‹ç®¡ç† ---
        const API_KEY = 'AIzaSyAG8dHLitnxl9ML6Rt2BHkSIw6wtu8nblY'; // æ‚¨çš„ API é‡‘é‘°
        const SEARCH_KEYWORDS = ["VSPOä¸­æ–‡", "VSPOä¸­æ–‡ç²¾è¯", "VSPOç²¾è¯", "VSPOä¸­æ–‡å‰ªè¼¯", "VSPOå‰ªè¼¯"];
        const OFFICIAL_CHANNEL_BLACKLIST = [
          'UCuI5_lA2o-arAIKukGvIEcQ', // ã¶ã„ã™ã½ã£ï¼ã€å…¬å¼ã€‘
          'UCGCb_d_H-A7A2y52M4S3W-w', // èŠ±èŠ½ã™ã¿ã‚Œ
          'UCyLGc23ry_p-zEAS_p_2qlg', // èŠ±èŠ½ãªãšãª
        ];
        const UPDATE_SCHEDULE = [
          '00:01', '01:01', '02:01', '07:01', '08:01', '09:01', '10:01', 
          '11:01', '11:31', '12:01', '12:31', '13:01', '14:01', '16:01', 
          '17:01', '17:31', '18:01', '19:01', '20:01', '21:01', '22:01', 
          '23:01'
        ];
        const DAILY_QUOTA = 10000;

        let state = {
            allVideos: [],
            isLoading: true,
            searchTerm: '',
            lastUpdated: null,
            nextUpdate: null,
            apiError: null,
            estimatedQuota: DAILY_QUOTA,
        };

        const appContainer = document.getElementById('app');
        let timeoutId = null;

        // --- UI å…ƒä»¶ç”¢ç”Ÿå™¨ (å–ä»£ React Components) ---

        function createSpinner() {
            const container = document.createElement('div');
            container.className = "flex flex-col items-center justify-center space-y-4 p-8";
            container.innerHTML = `
                <div class="w-16 h-16 border-4 border-blue-400 border-t-transparent border-solid rounded-full animate-spin"></div>
                <p class="text-lg text-gray-300">æ­£åœ¨å¾ YouTube å®‡å®™ä¸­å°‹æ‰¾æœ€æ–°çš„ VSPO ç²¾è¯... âœ¨</p>
            `;
            return container;
        }

        function createErrorDisplay(error) {
            const container = document.createElement('div');
            container.className = "bg-red-900/50 border border-red-500 text-red-200 px-4 py-3 rounded-lg text-center";
            container.innerHTML = `
                <strong class="font-bold">ç™¼ç”ŸéŒ¯èª¤ï¼</strong>
                <p class="block sm:inline ml-2">${error}</p>
                <p class="mt-2 text-sm">é€™å¯èƒ½æ˜¯å› ç‚º YouTube API é…é¡å·²ç”¨ç›¡ï¼Œè«‹æ–¼ä¸‹ä¸€å€‹æ’å®šæ™‚é–“å†è©¦ã€‚</p>
            `;
            return container;
        }
        
        function createVideoCard(video, showChannel = true) {
            const formatNumber = (num) => {
                if (typeof num !== 'number') return 'N/A';
                return num >= 10000 ? `${(num / 10000).toFixed(1)}è¬` : num.toLocaleString();
            };
            const timeAgo = (dateStr) => {
                const seconds = Math.floor((new Date() - new Date(dateStr)) / 1000);
                const intervals = { 'å¹´': 31536000, 'å€‹æœˆ': 2592000, 'å¤©': 86400, 'å°æ™‚': 3600, 'åˆ†é˜': 60 };
                for (let unit in intervals) {
                    let interval = seconds / intervals[unit];
                    if (interval > 1) return `${Math.floor(interval)} ${unit}å‰`;
                }
                return "å‰›å‰›";
            };

            const card = document.createElement('div');
            card.className = "bg-gray-800 rounded-lg overflow-hidden shadow-lg hover:shadow-cyan-400/30 transition-shadow duration-300 flex flex-col";
            
            const channelLink = showChannel ? `
                <a href="https://www.youtube.com/channel/${video.channelId}" target="_blank" rel="noopener noreferrer">
                    <p class="text-sm text-gray-400 mt-2 hover:text-white transition-colors">${video.channelTitle}</p>
                </a>` : '';

            card.innerHTML = `
                <a href="https://www.youtube.com/watch?v=${video.id}" target="_blank" rel="noopener noreferrer">
                    <img src="${video.thumbnail}" alt="${video.title}" class="w-full h-48 object-cover" onerror="this.onerror=null;this.src='https://placehold.co/480x360/1a202c/e53e3e?text=Image+Error';">
                </a>
                <div class="p-4 flex flex-col flex-grow">
                    <a href="https://www.youtube.com/watch?v=${video.id}" target="_blank" rel="noopener noreferrer" class="flex-grow">
                        <h3 class="font-bold text-lg text-gray-100 leading-tight hover:text-cyan-400 transition-colors">${video.title}</h3>
                    </a>
                    ${channelLink}
                    <div class="flex justify-between items-center text-sm text-gray-400 mt-3 pt-3 border-t border-gray-700">
                        <span>${formatNumber(video.viewCount)} æ¬¡è§€çœ‹</span>
                        <span>${timeAgo(video.publishedAt)}</span>
                    </div>
                </div>
            `;
            return card;
        }

        // --- API é…é¡ç®¡ç† ---
        function getTodaysDateString() {
            return new Date().toLocaleDateString('en-CA'); // YYYY-MM-DD
        }

        function loadQuota() {
            const storedQuota = localStorage.getItem('youtubeApiQuota');
            const today = getTodaysDateString();
            if (storedQuota) {
                const { date, quota } = JSON.parse(storedQuota);
                if (date === today) {
                    state.estimatedQuota = quota;
                } else {
                    // å¦‚æœä¸æ˜¯ä»Šå¤©ï¼Œé‡ç½®é…é¡
                    localStorage.setItem('youtubeApiQuota', JSON.stringify({ date: today, quota: DAILY_QUOTA }));
                    state.estimatedQuota = DAILY_QUOTA;
                }
            } else {
                 localStorage.setItem('youtubeApiQuota', JSON.stringify({ date: today, quota: DAILY_QUOTA }));
                 state.estimatedQuota = DAILY_QUOTA;
            }
        }

        function updateQuota(cost) {
            const newQuota = Math.max(0, state.estimatedQuota - cost);
            state.estimatedQuota = newQuota;
            localStorage.setItem('youtubeApiQuota', JSON.stringify({ date: getTodaysDateString(), quota: newQuota }));
        }

        // --- API è«‹æ±‚é‚è¼¯ ---
        const batchArray = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));
        
        async function fetchFanVideosFromYouTube() {
            let cost = 0; // åˆå§‹åŒ–æˆæœ¬è¨ˆç®—å™¨
            console.log("çœŸå¯¦ API è«‹æ±‚ï¼šé–‹å§‹æŠ“å–è³‡æ–™...");
            const oneMonthAgo = new Date();
            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
            const publishedAfter = oneMonthAgo.toISOString();

            const searchPromises = SEARCH_KEYWORDS.map(keyword =>
                fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(keyword)}&type=video&maxResults=50&publishedAfter=${publishedAfter}&key=${API_KEY}`)
                    .then(res => res.json())
            );
            cost += SEARCH_KEYWORDS.length * 100; // æœå°‹æˆæœ¬

            const searchResults = await Promise.all(searchPromises);
            // ... (å…¶é¤˜é‚è¼¯ä¸è®Š)
            const videoSnippets = new Map();
            for (const result of searchResults) {
                if (result.error) throw new Error(result.error.message);
                if (result.items) {
                    result.items.forEach(item => {
                        if (item.id.videoId && !videoSnippets.has(item.id.videoId) && !OFFICIAL_CHANNEL_BLACKLIST.includes(item.snippet.channelId)) {
                            videoSnippets.set(item.id.videoId, item.snippet);
                        }
                    });
                }
            }

            const videoIds = Array.from(videoSnippets.keys());
            if (videoIds.length === 0) return { videos: [], cost: cost };

            const videoDetailBatches = batchArray(videoIds, 50);
            cost += videoDetailBatches.length * 1; // å½±ç‰‡è©³æƒ…æˆæœ¬
            const videoDetailPromises = videoDetailBatches.map(batch =>
                fetch(`https://www.googleapis.com/youtube/v3/videos?part=statistics,snippet&id=${batch.join(',')}&key=${API_KEY}`).then(res => res.json())
            );
            const videoDetailResults = await Promise.all(videoDetailPromises);
            
            // ... (å…¶é¤˜é‚è¼¯ä¸è®Š)
            const videoDetailsMap = new Map();
            videoDetailResults.forEach(result => {
                if (result.error) throw new Error(result.error.message);
                result.items?.forEach(item => videoDetailsMap.set(item.id, item));
            });

            const channelIds = [...new Set(Array.from(videoSnippets.values()).map(s => s.channelId))];
            const channelDetailBatches = batchArray(channelIds, 50);
            cost += channelDetailBatches.length * 1; // é »é“è©³æƒ…æˆæœ¬
            const channelDetailPromises = channelDetailBatches.map(batch =>
                fetch(`https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${batch.join(',')}&key=${API_KEY}`).then(res => res.json())
            );
            const channelDetailResults = await Promise.all(channelDetailPromises);

            // ... (å…¶é¤˜é‚è¼¯ä¸è®Š)
            const channelStatsMap = new Map();
            channelDetailResults.forEach(result => {
                if (result.error) throw new Error(result.error.message);
                result.items?.forEach(item => channelStatsMap.set(item.id, item.statistics));
            });
            
            const finalVideos = videoIds.map(id => {
                const detail = videoDetailsMap.get(id);
                if (!detail) return null;
                const channelStats = channelStatsMap.get(detail.snippet.channelId);
                return {
                    id: id,
                    title: detail.snippet.title,
                    thumbnail: detail.snippet.thumbnails.high?.url || detail.snippet.thumbnails.default?.url,
                    channelId: detail.snippet.channelId,
                    channelTitle: detail.snippet.channelTitle,
                    publishedAt: detail.snippet.publishedAt,
                    viewCount: detail.statistics ? parseInt(detail.statistics.viewCount, 10) : 0,
                    subscriberCount: channelStats ? parseInt(channelStats.subscriberCount, 10) : 0,
                };
            }).filter(Boolean);

            console.log(`çœŸå¯¦ API è«‹æ±‚ï¼šå®Œæˆï¼ç¸½å…±è™•ç† ${finalVideos.length} éƒ¨ç²‰çµ²ç²¾è¯ã€‚æœ¬æ¬¡æ¶ˆè€—ç´„ ${cost} é…é¡ã€‚`);
            return { videos: finalVideos, cost: cost };
        }

        // --- ä¸»æ‡‰ç”¨ç¨‹å¼é‚è¼¯èˆ‡æ¸²æŸ“ ---
        
        function render() {
            const { allVideos, isLoading, searchTerm, lastUpdated, nextUpdate, apiError, estimatedQuota } = state;
            
            // ... (è¨ˆç®—éæ¿¾å¾Œè³‡æ–™çš„é‚è¼¯ä¸è®Š) ...
            const recentVideos = allVideos.slice(0, 10);
            const channels = {};
            allVideos.forEach(video => {
                if (!channels[video.channelId]) {
                    channels[video.channelId] = {
                        id: video.channelId, name: video.channelTitle,
                        subscriberCount: video.subscriberCount, latestVideo: video,
                    };
                }
            });
            const channelData = Object.values(channels).sort((a,b) => b.subscriberCount - a.subscriberCount);
            const lowerCaseSearchTerm = searchTerm.toLowerCase();
            const filteredRecentVideos = recentVideos.filter(v => !searchTerm || v.title.toLowerCase().includes(lowerCaseSearchTerm) || v.channelTitle.toLowerCase().includes(lowerCaseSearchTerm));
            const filteredChannelData = channelData.filter(c => !searchTerm || c.name.toLowerCase().includes(lowerCaseSearchTerm) || (c.latestVideo && c.latestVideo.title.toLowerCase().includes(lowerCaseSearchTerm)));

            // ... (æ¸²æŸ“ UI çš„é‚è¼¯ï¼ŒåŠ å…¥é…é¡é¡¯ç¤º) ...
            appContainer.innerHTML = '';
            const mainContainer = document.createElement('div');
            mainContainer.className = "container mx-auto px-4 py-8";
            
            let contentHtml;
             if (isLoading && allVideos.length === 0) {
                contentHtml = createSpinner().outerHTML;
            } else if (apiError) {
                contentHtml = createErrorDisplay(apiError).outerHTML;
            } else {
                const recentVideosSection = document.createElement('section');
                const recentVideosGrid = document.createElement('div');
                recentVideosGrid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-6';
                if(filteredRecentVideos.length > 0) {
                   filteredRecentVideos.forEach(video => recentVideosGrid.appendChild(createVideoCard(video)));
                } else {
                   recentVideosGrid.innerHTML = `<p class="text-gray-400">æ‰¾ä¸åˆ°ç¬¦åˆæ¢ä»¶çš„å½±ç‰‡ã€‚</p>`;
                }
                recentVideosSection.innerHTML = `<h2 class="text-3xl font-bold mb-6 border-l-4 border-cyan-400 pl-4">æœ€æ–°ç²¾è¯å½±ç‰‡</h2>`;
                recentVideosSection.appendChild(recentVideosGrid);

                const channelListSection = document.createElement('section');
                const channelListContainer = document.createElement('div');
                channelListContainer.className = 'space-y-6';
                if(filteredChannelData.length > 0) {
                    filteredChannelData.forEach(channel => {
                        const channelCard = document.createElement('div');
                        const formatNumber = (num) => num >= 10000 ? `${(num / 10000).toFixed(1)}è¬` : num.toLocaleString();
                        channelCard.className = "bg-gray-800 p-4 rounded-lg flex flex-col md:flex-row items-start gap-4 shadow-lg hover:shadow-purple-400/30 transition-shadow duration-300";
                        channelCard.innerHTML = `
                            <div class="w-full md:w-1/3 lg:w-1/4 flex-shrink-0">
                                <a href="https://www.youtube.com/channel/${channel.id}" target="_blank" rel="noopener noreferrer" class="block mb-2">
                                    <h3 class="text-xl font-bold hover:text-purple-400 transition-colors">${channel.name}</h3>
                                </a>
                                <p class="text-gray-400">${formatNumber(channel.subscriberCount)} ä½è¨‚é–±è€…</p>
                            </div>`;
                        const videoWrapper = document.createElement('div');
                        videoWrapper.className = 'w-full md:w-2/3 lg:w-3/4';
                        videoWrapper.innerHTML = `<p class="text-sm text-gray-400 mb-2">æœ€æ–°å½±ç‰‡:</p>`;
                        videoWrapper.appendChild(createVideoCard(channel.latestVideo, false));
                        channelCard.appendChild(videoWrapper);
                        channelListContainer.appendChild(channelCard);
                    });
                } else {
                    channelListContainer.innerHTML = `<p class="text-gray-400">æ‰¾ä¸åˆ°ç¬¦åˆæ¢ä»¶çš„é »é“ã€‚</p>`;
                }
                channelListSection.innerHTML = `<h2 class="text-3xl font-bold mb-6 border-l-4 border-cyan-400 pl-4 mt-12">ç²¾è¯é »é“åˆ—è¡¨</h2>`;
                channelListSection.appendChild(channelListContainer);
                
                contentHtml = recentVideosSection.outerHTML + channelListSection.outerHTML;
            }

            mainContainer.innerHTML = `
                <header class="text-center mb-8">
                    <h1 class="text-4xl md:text-5xl font-bold text-cyan-400">VSPOä¸­æ–‡ç²¾è¯æ”¶é›†å™¨</h1>
                </header>
                <div class="sticky top-0 z-10 bg-gray-900/80 backdrop-blur-sm py-4 mb-8">
                    <div class="max-w-3xl mx-auto">
                        <input
                            type="text"
                            id="search-input"
                            placeholder="ğŸ” æœå°‹å½±ç‰‡æ¨™é¡Œæˆ–é »é“åç¨±..."
                            value="${searchTerm}"
                            class="w-full px-5 py-3 bg-gray-800 text-white border-2 border-gray-700 rounded-full focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent transition-all"
                        />
                    </div>
                    <div class="text-center text-sm text-gray-500 mt-3 flex justify-center items-center space-x-4 flex-wrap">
                        <span class="whitespace-nowrap">ğŸ“Š é ä¼°é…é¡é¤˜é¡: <span class="font-semibold text-green-400">${estimatedQuota.toLocaleString()}</span></span>
                        ${lastUpdated ? `<span class="whitespace-nowrap">æœ€å¾Œæ›´æ–°: ${lastUpdated.toLocaleTimeString()}</span>` : ''}
                        ${nextUpdate ? `<span class="whitespace-nowrap">ä¸‹æ¬¡æ›´æ–°: ${nextUpdate.toLocaleTimeString()}</span>` : ''}
                    </div>
                </div>
                <div>${contentHtml}</div>
            `;

            appContainer.appendChild(mainContainer);
            document.getElementById('search-input').addEventListener('input', (e) => {
                state.searchTerm = e.target.value;
                render();
            });
        }

        async function fetchData() {
            state.isLoading = true;
            state.apiError = null;
            render();
            try {
                const { videos, cost } = await fetchFanVideosFromYouTube();
                updateQuota(cost); // æ›´æ–°é…é¡
                state.allVideos = videos.sort((a, b) => new Date(b.publishedAt) - new Date(a.publishedAt));
                state.lastUpdated = new Date();
            } catch (error) {
                console.error("API è«‹æ±‚å¤±æ•—:", error);
                state.apiError = error.message;
            } finally {
                state.isLoading = false;
                render();
            }
        }

        function scheduleNextUpdate() {
             if (timeoutId) clearTimeout(timeoutId);
             // ... (å…¶é¤˜æ’ç¨‹é‚è¼¯ä¸è®Š) ...
            const now = new Date();
            let nextUpdateTime = null;
            for (const timeStr of UPDATE_SCHEDULE) {
                const [hours, minutes] = timeStr.split(':').map(Number);
                const candidateTime = new Date(now);
                candidateTime.setHours(hours, minutes, 0, 0);
                if (candidateTime > now) {
                    nextUpdateTime = candidateTime;
                    break;
                }
            }
            if (!nextUpdateTime) {
                const [hours, minutes] = UPDATE_SCHEDULE[0].split(':').map(Number);
                nextUpdateTime = new Date();
                nextUpdateTime.setDate(nextUpdateTime.getDate() + 1);
                nextUpdateTime.setHours(hours, minutes, 0, 0);
            }
            state.nextUpdate = nextUpdateTime;
            const msUntilNextUpdate = nextUpdateTime.getTime() - now.getTime();
            console.log(`ä¸‹ä¸€æ¬¡æ›´æ–°æ’å®šæ–¼: ${nextUpdateTime.toLocaleString()}, å°‡åœ¨ ${Math.round(msUntilNextUpdate / 1000 / 60)} åˆ†é˜å¾ŒåŸ·è¡Œã€‚`);
            timeoutId = setTimeout(() => {
                fetchData().then(() => scheduleNextUpdate());
            }, msUntilNextUpdate);
            render();
        }

        // --- æ‡‰ç”¨ç¨‹å¼å•Ÿå‹• ---
        loadQuota(); // å•Ÿå‹•æ™‚è®€å–å„²å­˜çš„é…é¡
        fetchData().then(() => scheduleNextUpdate());

    </script>
</body>
</html>